#include "Audio.h"
#include "Exception.h"

namespace bloom {
	_Basic_Music_Store* _Basic_Music_Store::m_currentObjectPtr = nullptr;


	Music::Music(std::string fileName) {
		load(fileName);
	}

	Music::~Music() {
		stop();
		Mix_FreeMusic(m_track);
		m_track = nullptr;
	}

	void Music::load(std::string fileName) {
		m_track = Mix_LoadMUS(fileName.c_str());

		if (m_track == NULL)
			throw Exception("[SDL_Mixer] " + std::string(SDL_GetError()));
	}

	void Music::play(int plays) {
		if (m_track == NULL or m_track == nullptr) {
			throw Exception("[SDL_Mixer] there is no file to play track");
		}

		if (Mix_PlayMusic(m_track, plays) == -1)
			throw Exception("[SDL_Mixer] " + std::string(SDL_GetError()));
	}

	void Music::pause() {
		if (Mix_PausedMusic() == 0)
			Mix_PauseMusic();
		else
			Mix_ResumeMusic();
	}

	void Music::resume() {
		if (Mix_PausedMusic() != 0)
			Mix_ResumeMusic();
		else
			Mix_PauseMusic();
	}

	void Music::stop() {
		Mix_HaltMusic();
	}



	SoundFX::SoundFX(std::string fileName, int channel) {
		m_channel = channel;
		load(fileName);
	}

	SoundFX::~SoundFX() {
		Mix_FreeChunk(m_chunk);
	}

	void SoundFX::load(std::string fileName) {
		m_chunk = Mix_LoadWAV(fileName.c_str());

		if (m_chunk == NULL)
			throw Exception("[SDL_Mixer] " + std::string(SDL_GetError()));
	}

	void SoundFX::play(int loops) {
		if (m_chunk == NULL or m_chunk == nullptr) {
			throw Exception("[SDL_Mixer] there is no file to play chunk");
		}

		if (Mix_PlayChannel(m_channel, m_chunk, loops) == -1)
			throw Exception("[SDL_Mixer] " + std::string(SDL_GetError()));
	}

	void SoundFX::pause() {
		if (Mix_Paused(m_channel) == 0)
			Mix_Pause(m_channel);
		else
			Mix_Resume(m_channel);
	}

	void SoundFX::resume() {
		if (Mix_Paused(m_channel) != 0)
			Mix_Resume(m_channel);
		else
			Mix_Pause(m_channel);
	}

	void SoundFX::stop() {
		Mix_HaltChannel(m_channel);
	}



	_Basic_Music_Store::_Basic_Music_Store(bool infinitePlayback) : m_infinitePlayback(infinitePlayback) {}

	_Basic_Music_Store::~_Basic_Music_Store() {
		clear();
		exit();
	}

	void _Basic_Music_Store::launch() {
		m_oldObjectPtr = m_currentObjectPtr;
		m_currentObjectPtr = this;
		Mix_HookMusicFinished((void(*) ())(_Basic_Music_Store::next_track));
	}

	void _Basic_Music_Store::add(std::string fileName, int plays, bool ignoreInfinitePlayback) {
		m_store.push({ new Music(fileName), plays, ignoreInfinitePlayback });
	}

	void _Basic_Music_Store::remove() {
		if (!m_store.empty()) {
			exit();
			m_store.front().track->stop();
			m_store.pop();
			launch();
			if (!m_store.empty())
				play();
		}
	}

	void _Basic_Music_Store::play() {
		if (m_store.empty())
			throw Exception("[MusicStore] store is empty");
		if (m_currentObjectPtr != this)
			launch();
		auto track = m_store.front();
		track.track->play(track.plays);
	}

	void _Basic_Music_Store::pause() {
		m_store.front().track->pause();
	}

	void _Basic_Music_Store::resume() {
		m_store.front().track->resume();
	}

	void _Basic_Music_Store::skip() {
		m_store.front().track->stop();
	}

	void _Basic_Music_Store::clear() {
		m_store = std::queue<Track>();
	}

	void _Basic_Music_Store::exit() {
		if (m_currentObjectPtr == this) {
			m_currentObjectPtr = m_oldObjectPtr;
			Mix_HookMusicFinished((void(*) ())(_Basic_Music_Store::next_track));
		}
	}

	void _Basic_Music_Store::setInfinitePlayback(bool value) {
		m_infinitePlayback = value;
	}

	bool _Basic_Music_Store::isInfinitePlayback() {
		return m_infinitePlayback;
	}

	void _Basic_Music_Store::next_track() {
		if (m_currentObjectPtr != nullptr) {
			if (!m_currentObjectPtr->m_store.front().ignoreInfinitePlayback && m_currentObjectPtr->m_infinitePlayback) {
				m_currentObjectPtr->m_store.push(m_currentObjectPtr->m_store.front());
			}
			m_currentObjectPtr->m_store.pop();

			if (!m_currentObjectPtr->m_store.empty())
				m_currentObjectPtr->play();
		}
	}
}